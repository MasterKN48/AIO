{"version":3,"sources":["../../lib/utils.js","../../lib/image-compression.js","../../lib/web-worker.js","../../lib/index.js","component/Compression.js","component/Algorithms/compression/PNG_JPG_Compressor.js","component/Algorithms/compression/WEBPCompressor.js","component/Algorithms/compression/PDFCompressor.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"],"names":["isBrowser","window","CustomFile","getFilefromDataUrl","n","bstr","file","e","img","type","fileName","length","offset","i","height","maxWidthOrHeight","options","ctx","width","getNewCanvasAndCtx","canvas","inc","then","maxSizeByte","currentSize","imageCompressionLibUrl","cnt","generateLib","script","imageCompression","getDataUrlFromFile","Compression","useState","setFile","ratio","setRatio","success","setSuccess","load","setLoading","from","setType","className","name","onChange","target","value","defaultValue","accept","files","step","id","min","max","Number","onClick","preventDefault","size","alert","toLowerCase","split","pop","maxSizeMB","useWebWorker","compressedFile","blob","reader","FileReader","readAsDataURL","onloadend","dataURI","result","document","getElementById","innerText","toFixed","download","href","catch","error","console","log","message","PNG_JPG_Compressor","onload","dataURL","setSucess","getContext","image","Image","innerWidth","innerHeight","drawImage","src","toDataURL","replace","imgFileSize","Math","round","WEBPCompressor","readAsArrayBuffer","PDFCompressor","style","display","si","byteString","atob","mimeString","arrayBuffer","ArrayBuffer","_ia","Uint8Array","charCodeAt","dataView","DataView","Blob","URL","createObjectURL","downloadWEBP","_defineProperty","obj","key","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_arrayLikeToArray","arr","len","arr2","Array","_slicedToArray","isArray","Symbol","iterator","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","o","minLen","prototype","toString","call","slice","constructor","test","TypeError"],"mappings":"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","file":"static/js/6.b66ab76f.chunk.js","sourcesContent":["const isBrowser = typeof window !== 'undefined' // change browser environment to support SSR\r\n\r\n// add support for cordova-plugin-file\r\nconst moduleMapper = isBrowser && window.cordova && window.cordova.require && window.cordova.require('cordova/modulemapper')\r\nexport const CustomFile = isBrowser && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'File')) || File)\r\nexport const CustomFileReader = isBrowser && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'FileReader')) || FileReader)\r\n\r\n// Check if browser supports automatic image orientation\r\n// see https://github.com/blueimp/JavaScript-Load-Image/blob/1e4df707821a0afcc11ea0720ee403b8759f3881/js/load-image-orientation.js#L37-L53\r\nexport const isAutoOrientationInBrowser = (async () => {\r\n  // black 2x1 JPEG, with the following meta information set:\r\n  // EXIF Orientation: 6 (Rotated 90° CCW)\r\n  const testImageURL =\r\n    'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\r\n    'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\r\n    'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\r\n    'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' +\r\n    'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' +\r\n    'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q=='\r\n  const testImageFile = await getFilefromDataUrl(testImageURL, 'test.jpg', Date.now())\r\n\r\n  const testImageCanvas = (await drawFileInCanvas(testImageFile))[1]\r\n  const testImageFile2 = await canvasToFile(testImageCanvas, testImageFile.type, testImageFile.name, testImageFile.lastModified)\r\n  cleanupCanvasMemory(testImageCanvas)\r\n  const testImageURL2 = await getDataUrlFromFile(testImageFile2)\r\n  const img = await loadImage(testImageURL2)\r\n  // console.log('img', img.width, img.height)\r\n\r\n  return img.width === 1 && img.height === 2\r\n})()\r\n\r\n/**\r\n * getDataUrlFromFile\r\n *\r\n * @param {File | Blob} file\r\n * @returns {Promise<string>}\r\n */\r\nexport function getDataUrlFromFile (file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new CustomFileReader()\r\n    reader.onload = () => resolve(reader.result)\r\n    reader.onerror = (e) => reject(e)\r\n    reader.readAsDataURL(file)\r\n  })\r\n}\r\n\r\n/**\r\n * getFilefromDataUrl\r\n *\r\n * @param {string} dataUrl\r\n * @param {string} filename\r\n * @param {number} [lastModified=Date.now()]\r\n * @returns {Promise<File | Blob>}\r\n */\r\nexport function getFilefromDataUrl (dataUrl, filename, lastModified = Date.now()) {\r\n  return new Promise((resolve) => {\r\n    const arr = dataUrl.split(',')\r\n    const mime = arr[0].match(/:(.*?);/)[1]\r\n    const bstr = atob(arr[1])\r\n    let n = bstr.length\r\n    const u8arr = new Uint8Array(n)\r\n    while (n--) {\r\n      u8arr[n] = bstr.charCodeAt(n)\r\n    }\r\n    const file = new Blob([u8arr], { type: mime })\r\n    file.name = filename\r\n    file.lastModified = lastModified\r\n    resolve(file)\r\n\r\n    // Safari has issue with File constructor not being able to POST in FormData\r\n    // https://github.com/Donaldcwl/browser-image-compression/issues/8\r\n    // https://bugs.webkit.org/show_bug.cgi?id=165081\r\n    // let file\r\n    // try {\r\n    //   file = new File([u8arr], filename, { type: mime }) // Edge do not support File constructor\r\n    // } catch (e) {\r\n    //   file = new Blob([u8arr], { type: mime })\r\n    //   file.name = filename\r\n    //   file.lastModified = lastModified\r\n    // }\r\n    // resolve(file)\r\n  })\r\n}\r\n\r\n/**\r\n * loadImage\r\n *\r\n * @param {string} src\r\n * @returns {Promise<HTMLImageElement>}\r\n */\r\nexport function loadImage (src) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image()\r\n    img.onload = () => resolve(img)\r\n    img.onerror = (e) => reject(e)\r\n    img.src = src\r\n  })\r\n}\r\n\r\n/**\r\n * drawImageInCanvas\r\n *\r\n * @param {HTMLImageElement} img\r\n * @returns {HTMLCanvasElement | OffscreenCanvas}\r\n */\r\nexport function drawImageInCanvas (img) {\r\n  const [canvas, ctx] = getNewCanvasAndCtx(img.width, img.height)\r\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\r\n  return canvas\r\n}\r\n\r\n/**\r\n * drawFileInCanvas\r\n *\r\n * @param {File | Blob} file\r\n * @returns {Promise<[ImageBitmap | HTMLImageElement, HTMLCanvasElement | OffscreenCanvas]>}\r\n */\r\nexport async function drawFileInCanvas (file) {\r\n  let img\r\n  try {\r\n    img = await createImageBitmap(file)\r\n  } catch (e) {\r\n    const dataUrl = await getDataUrlFromFile(file)\r\n    img = await loadImage(dataUrl)\r\n  }\r\n  const canvas = drawImageInCanvas(img)\r\n  return [img, canvas]\r\n}\r\n\r\n/**\r\n * canvasToFile\r\n *\r\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\r\n * @param {string} fileType\r\n * @param {string} fileName\r\n * @param {number} fileLastModified\r\n * @param {number} [quality]\r\n * @returns {Promise<File | Blob>}\r\n */\r\nexport async function canvasToFile (canvas, fileType, fileName, fileLastModified, quality = 1) {\r\n  let file\r\n  if (typeof OffscreenCanvas === 'function' && canvas instanceof OffscreenCanvas) {\r\n    file = await canvas.convertToBlob({ type: fileType, quality })\r\n    file.name = fileName\r\n    file.lastModified = fileLastModified\r\n  } else {\r\n    const dataUrl = canvas.toDataURL(fileType, quality)\r\n    file = await getFilefromDataUrl(dataUrl, fileName, fileLastModified)\r\n  }\r\n  return file\r\n}\r\n\r\n/**\r\n * getExifOrientation\r\n * get image exif orientation info\r\n * source: https://stackoverflow.com/a/32490603/10395024\r\n *\r\n * @param {File | Blob} file\r\n * @returns {Promise<number>} - orientation id, see https://i.stack.imgur.com/VGsAj.gif\r\n */\r\nexport function getExifOrientation (file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new CustomFileReader()\r\n    reader.onload = (e) => {\r\n      const view = new DataView(e.target.result)\r\n      if (view.getUint16(0, false) != 0xFFD8) {\r\n        return resolve(-2)\r\n      }\r\n      const length = view.byteLength\r\n      let offset = 2\r\n      while (offset < length) {\r\n        if (view.getUint16(offset + 2, false) <= 8) return resolve(-1)\r\n        const marker = view.getUint16(offset, false)\r\n        offset += 2\r\n        if (marker == 0xFFE1) {\r\n          if (view.getUint32(offset += 2, false) != 0x45786966) {\r\n            return resolve(-1)\r\n          }\r\n\r\n          var little = view.getUint16(offset += 6, false) == 0x4949\r\n          offset += view.getUint32(offset + 4, little)\r\n          var tags = view.getUint16(offset, little)\r\n          offset += 2\r\n          for (var i = 0; i < tags; i++) {\r\n            if (view.getUint16(offset + (i * 12), little) == 0x0112) {\r\n              return resolve(view.getUint16(offset + (i * 12) + 8, little))\r\n            }\r\n          }\r\n        } else if ((marker & 0xFF00) != 0xFF00) {\r\n          break\r\n        } else {\r\n          offset += view.getUint16(offset, false)\r\n        }\r\n      }\r\n      return resolve(-1)\r\n    }\r\n    reader.onerror = (e) => reject(e)\r\n    reader.readAsArrayBuffer(file)\r\n  })\r\n}\r\n\r\n/**\r\n *\r\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\r\n * @param options\r\n * @returns {HTMLCanvasElement | OffscreenCanvas}\r\n */\r\nexport function handleMaxWidthOrHeight (canvas, options) {\r\n  const width = canvas.width\r\n  const height = canvas.height\r\n  const maxWidthOrHeight = options.maxWidthOrHeight\r\n\r\n  const needToHandle = isFinite(maxWidthOrHeight) && (width > maxWidthOrHeight || height > maxWidthOrHeight)\r\n\r\n  let newCanvas = canvas\r\n  let ctx\r\n\r\n  if (needToHandle) {\r\n    [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\r\n    if (width > height) {\r\n      newCanvas.width = maxWidthOrHeight\r\n      newCanvas.height = (height / width) * maxWidthOrHeight\r\n    } else {\r\n      newCanvas.width = (width / height) * maxWidthOrHeight\r\n      newCanvas.height = maxWidthOrHeight\r\n    }\r\n    ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height)\r\n\r\n    cleanupCanvasMemory(canvas)\r\n  }\r\n\r\n  return newCanvas\r\n}\r\n\r\n/**\r\n * followExifOrientation\r\n * source: https://stackoverflow.com/a/40867559/10395024\r\n *\r\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\r\n * @param {number} exifOrientation\r\n * @returns {HTMLCanvasElement | OffscreenCanvas} canvas\r\n */\r\nexport function followExifOrientation (canvas, exifOrientation) {\r\n  const width = canvas.width\r\n  const height = canvas.height\r\n\r\n  const [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\r\n\r\n  // set proper canvas dimensions before transform & export\r\n  if (4 < exifOrientation && exifOrientation < 9) {\r\n    newCanvas.width = height\r\n    newCanvas.height = width\r\n  } else {\r\n    newCanvas.width = width\r\n    newCanvas.height = height\r\n  }\r\n\r\n  // transform context before drawing image\r\n  switch (exifOrientation) {\r\n    case 2: ctx.transform(-1, 0, 0, 1, width, 0); break;\r\n    case 3: ctx.transform(-1, 0, 0, -1, width, height); break;\r\n    case 4: ctx.transform(1, 0, 0, -1, 0, height); break;\r\n    case 5: ctx.transform(0, 1, 1, 0, 0, 0); break;\r\n    case 6: ctx.transform(0, 1, -1, 0, height, 0); break;\r\n    case 7: ctx.transform(0, -1, -1, 0, height, width); break;\r\n    case 8: ctx.transform(0, -1, 1, 0, 0, width); break;\r\n    default: break;\r\n  }\r\n\r\n  ctx.drawImage(canvas, 0, 0, width, height)\r\n\r\n  cleanupCanvasMemory(canvas)\r\n\r\n  return newCanvas\r\n}\r\n\r\n/**\r\n * get new Canvas and it's context\r\n * @param width\r\n * @param height\r\n * @returns {[HTMLCanvasElement | OffscreenCanvas, CanvasRenderingContext2D]}\r\n */\r\nexport function getNewCanvasAndCtx (width, height) {\r\n  let canvas\r\n  let ctx\r\n  try {\r\n    canvas = new OffscreenCanvas(width, height)\r\n    ctx = canvas.getContext('2d')\r\n    if (ctx === null) {\r\n      throw new Error('getContext of OffscreenCanvas returns null')\r\n    }\r\n  } catch (e) {\r\n    canvas = document.createElement('canvas')\r\n    ctx = canvas.getContext('2d')\r\n  }\r\n  canvas.width = width\r\n  canvas.height = height\r\n  return [canvas, ctx]\r\n}\r\n\r\n/**\r\n * clear Canvas memory\r\n * @param canvas\r\n * @returns null\r\n */\r\nexport function cleanupCanvasMemory (canvas) {\r\n  canvas.width = 0\r\n  canvas.height = 0\r\n}\r\n\r\nif (isBrowser) {\r\n// Polyfill for Number.isInteger\r\n  Number.isInteger = Number.isInteger || function (value) {\r\n    return typeof value === 'number' &&\r\n      isFinite(value) &&\r\n      Math.floor(value) === value\r\n  }\r\n}\r\n","import {\r\n  canvasToFile,\r\n  cleanupCanvasMemory,\r\n  drawFileInCanvas,\r\n  followExifOrientation,\r\n  getExifOrientation,\r\n  getNewCanvasAndCtx,\r\n  handleMaxWidthOrHeight,\r\n  isAutoOrientationInBrowser\r\n} from './utils'\r\n\r\n/**\r\n * Compress an image file.\r\n *\r\n * @param {File} file\r\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=false, maxIteration = 10, exifOrientation, fileType }\r\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\r\n * @param {number} [options.maxWidthOrHeight=undefined]\r\n * @param {number} [options.maxIteration=10]\r\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\r\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\r\n * @param {string} [options.fileType] - default to be the original mime type from the image file\r\n * @returns {Promise<File | Blob>}\r\n */\r\nexport default async function compress (file, options) {\r\n  let progress = 0\r\n\r\n  function incProgress (inc = 5) {\r\n    progress += inc\r\n    options.onProgress(Math.min(progress, 100))\r\n  }\r\n\r\n  function setProgress (p) {\r\n    progress = Math.min(Math.max(p, progress), 100)\r\n    options.onProgress(progress)\r\n  }\r\n\r\n  let remainingTrials = options.maxIteration || 10\r\n\r\n  const maxSizeByte = options.maxSizeMB * 1024 * 1024\r\n\r\n  incProgress()\r\n\r\n  // drawFileInCanvas\r\n  let [img, origCanvas] = await drawFileInCanvas(file)\r\n\r\n  incProgress()\r\n\r\n  // handleMaxWidthOrHeight\r\n  const maxWidthOrHeightFixedCanvas = handleMaxWidthOrHeight(origCanvas, options)\r\n\r\n  incProgress()\r\n\r\n  // exifOrientation\r\n  options.exifOrientation = options.exifOrientation || await getExifOrientation(file)\r\n  incProgress()\r\n  const orientationFixedCanvas = (await isAutoOrientationInBrowser) ? maxWidthOrHeightFixedCanvas : followExifOrientation(maxWidthOrHeightFixedCanvas, options.exifOrientation)\r\n  incProgress()\r\n\r\n  let quality = 1\r\n\r\n  let tempFile = await canvasToFile(orientationFixedCanvas, options.fileType || file.type, file.name, file.lastModified, quality)\r\n  incProgress()\r\n\r\n  const origExceedMaxSize = tempFile.size > maxSizeByte\r\n  const sizeBecomeLarger = tempFile.size > file.size\r\n\r\n  // check if we need to compress or resize\r\n  if (!origExceedMaxSize && !sizeBecomeLarger) {\r\n    // no need to compress\r\n    setProgress(100)\r\n    return tempFile\r\n  }\r\n\r\n  const sourceSize = file.size\r\n  const renderedSize = tempFile.size\r\n  let currentSize = renderedSize\r\n  let compressedFile\r\n  let newCanvas, ctx\r\n  let canvas = orientationFixedCanvas\r\n  while (remainingTrials-- && (currentSize > maxSizeByte || currentSize > sourceSize)) {\r\n    const newWidth = origExceedMaxSize ? canvas.width * 0.95 : canvas.width\r\n    const newHeight = origExceedMaxSize ? canvas.height * 0.95 : canvas.height;\r\n    [newCanvas, ctx] = getNewCanvasAndCtx(newWidth, newHeight)\r\n\r\n    ctx.drawImage(canvas, 0, 0, newWidth, newHeight)\r\n\r\n    if (file.type === 'image/jpeg') {\r\n      quality *= 0.95\r\n    }\r\n    compressedFile = await canvasToFile(newCanvas, options.fileType || file.type, file.name, file.lastModified, quality)\r\n\r\n    cleanupCanvasMemory(canvas)\r\n\r\n    canvas = newCanvas\r\n\r\n    currentSize = compressedFile.size\r\n    setProgress(Math.min(99, Math.floor((renderedSize - currentSize) / (renderedSize - maxSizeByte) * 100)))\r\n  }\r\n\r\n  // garbage clean canvas for safari\r\n  // ref: https://bugs.webkit.org/show_bug.cgi?id=195325\r\n  cleanupCanvasMemory(canvas)\r\n  cleanupCanvasMemory(newCanvas)\r\n  cleanupCanvasMemory(maxWidthOrHeightFixedCanvas)\r\n  cleanupCanvasMemory(orientationFixedCanvas)\r\n  cleanupCanvasMemory(origCanvas)\r\n\r\n  setProgress(100)\r\n  return compressedFile\r\n}\r\n","import lib from './index'\r\nimport compress from './image-compression'\r\nimport { getNewCanvasAndCtx } from './utils'\r\n\r\nlet cnt = 0\r\nlet imageCompressionLibUrl\r\nlet worker\r\n\r\nfunction createWorker (script) {\r\n  if (typeof script === 'function') {\r\n    script = `(${f})()`\r\n  }\r\n  return new Worker(URL.createObjectURL(new Blob([script])))\r\n}\r\n\r\nfunction createSourceObject (str) {\r\n  return URL.createObjectURL(new Blob([str], { type: 'application/javascript' }))\r\n}\r\n\r\nfunction generateLib () {\r\n  // prepare the lib to be used inside WebWorker\r\n  return createSourceObject(`\r\n    function imageCompression (){return (${lib}).apply(null, arguments)}\r\n\r\n    imageCompression.getDataUrlFromFile = ${lib.getDataUrlFromFile}\r\n    imageCompression.getFilefromDataUrl = ${lib.getFilefromDataUrl}\r\n    imageCompression.loadImage = ${lib.loadImage}\r\n    imageCompression.drawImageInCanvas = ${lib.drawImageInCanvas}\r\n    imageCompression.drawFileInCanvas = ${lib.drawFileInCanvas}\r\n    imageCompression.canvasToFile = ${lib.canvasToFile}\r\n    imageCompression.getExifOrientation = ${lib.getExifOrientation}\r\n    imageCompression.handleMaxWidthOrHeight = ${lib.handleMaxWidthOrHeight}\r\n    imageCompression.followExifOrientation = ${lib.followExifOrientation}\r\n    imageCompression.cleanupMemory = ${lib.cleanupMemory}\r\n\r\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\r\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\r\n    loadImage = imageCompression.loadImage\r\n    drawImageInCanvas = imageCompression.drawImageInCanvas\r\n    drawFileInCanvas = imageCompression.drawFileInCanvas\r\n    canvasToFile = imageCompression.canvasToFile\r\n    getExifOrientation = imageCompression.getExifOrientation\r\n    handleMaxWidthOrHeight = imageCompression.handleMaxWidthOrHeight\r\n    followExifOrientation = imageCompression.followExifOrientation\r\n    cleanupMemory = imageCompression.cleanupMemory\r\n\r\n    getNewCanvasAndCtx = ${getNewCanvasAndCtx}\r\n    \r\n    CustomFileReader = FileReader\r\n    \r\n    CustomFile = File\r\n    \r\n    function _slicedToArray(arr, n) { return arr }\r\n    \r\n    function _typeof(a) { return typeof a }\r\n\r\n    function compress (){return (${compress}).apply(null, arguments)}\r\n    `)\r\n}\r\n\r\nfunction generateWorkerScript () {\r\n  // code to be run in the WebWorker\r\n  return createWorker(`\r\n    let scriptImported = false\r\n    self.addEventListener('message', async (e) => {\r\n      const { file, id, imageCompressionLibUrl, options } = e.data\r\n      options.onProgress = (progress) => self.postMessage({ progress, id })\r\n      try {\r\n        if (!scriptImported) {\r\n          // console.log('[worker] importScripts', imageCompressionLibUrl)\r\n          self.importScripts(imageCompressionLibUrl)\r\n          scriptImported = true\r\n        }\r\n        // console.log('[worker] self', self)\r\n        const compressedFile = await imageCompression(file, options)\r\n        self.postMessage({ file: compressedFile, id })\r\n      } catch (e) {\r\n        // console.error('[worker] error', e)\r\n        self.postMessage({ error: e.message + '\\\\n' + e.stack, id })\r\n      }\r\n    })\r\n  `)\r\n}\r\n\r\nexport function compressOnWebWorker (file, options) {\r\n  return new Promise(async (resolve, reject) => {\r\n    let id = cnt++\r\n\r\n    if (!imageCompressionLibUrl) {\r\n      imageCompressionLibUrl = generateLib()\r\n    }\r\n\r\n    if (!worker) {\r\n      worker = generateWorkerScript()\r\n    }\r\n\r\n    function handler (e) {\r\n      if (e.data.id === id) {\r\n        if (e.data.progress !== undefined) {\r\n          options.onProgress(e.data.progress)\r\n          return\r\n        }\r\n        worker.removeEventListener('message', handler)\r\n        if (e.data.error) {\r\n          reject(new Error(e.data.error))\r\n        }\r\n        resolve(e.data.file)\r\n      }\r\n    }\r\n\r\n    worker.addEventListener('message', handler)\r\n    worker.addEventListener('error', reject)\r\n\r\n    worker.postMessage({\r\n      file,\r\n      id,\r\n      imageCompressionLibUrl,\r\n      options: { ...options, onProgress: undefined }\r\n    })\r\n  })\r\n}\r\n","import compress from './image-compression'\r\nimport {\r\n  canvasToFile,\r\n  drawFileInCanvas,\r\n  drawImageInCanvas,\r\n  getDataUrlFromFile,\r\n  getFilefromDataUrl,\r\n  loadImage,\r\n  getExifOrientation,\r\n  handleMaxWidthOrHeight,\r\n  followExifOrientation,\r\n  CustomFile,\r\n  cleanupCanvasMemory\r\n} from './utils'\r\nimport { compressOnWebWorker } from './web-worker'\r\n\r\n/**\r\n * Compress an image file.\r\n *\r\n * @param {File} file\r\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=false, maxIteration = 10, exifOrientation, fileType }\r\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\r\n * @param {number} [options.maxWidthOrHeight=undefined]\r\n * @param {boolean} [options.useWebWorker=false]\r\n * @param {number} [options.maxIteration=10]\r\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\r\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\r\n * @param {string} [options.fileType] - default to be the original mime type from the image file\r\n * @returns {Promise<File | Blob>}\r\n */\r\nasync function imageCompression (file, options) {\r\n\r\n  let compressedFile\r\n\r\n  options.maxSizeMB = options.maxSizeMB || Number.POSITIVE_INFINITY\r\n  const useWebWorker = typeof options.useWebWorker === 'boolean' ? options.useWebWorker : true\r\n  delete options.useWebWorker\r\n  if (options.onProgress === undefined) {\r\n    options.onProgress = () => {}\r\n  }\r\n\r\n  if (!(file instanceof Blob || file instanceof CustomFile)) {\r\n    throw new Error('The file given is not an instance of Blob or File')\r\n  } else if (!/^image/.test(file.type)) {\r\n    throw new Error('The file given is not an image')\r\n  }\r\n\r\n  // try run in web worker, fall back to run in main thread\r\n  const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\r\n\r\n  // if ((useWebWorker && typeof Worker === 'function') || inWebWorker) {\r\n  //   console.log('run compression in web worker')\r\n  // } else {\r\n  //   console.log('run compression in main thread')\r\n  // }\r\n\r\n  if (useWebWorker && typeof Worker === 'function' && !inWebWorker) {\r\n    try {\r\n      // console.log(1)\r\n      // \"compressOnWebWorker\" is kind of like a recursion to call \"imageCompression\" again inside web worker\r\n      compressedFile = await compressOnWebWorker(file, options)\r\n    } catch (e) {\r\n      // console.warn('Run compression in web worker failed:', e, ', fall back to main thread')\r\n      // console.log(1.5)\r\n      compressedFile = await compress(file, options)\r\n    }\r\n  } else {\r\n    // console.log(2)\r\n    compressedFile = await compress(file, options)\r\n  }\r\n\r\n  try {\r\n    compressedFile.name = file.name\r\n    compressedFile.lastModified = file.lastModified\r\n  } catch (e) {}\r\n\r\n  return compressedFile\r\n}\r\n\r\nimageCompression.getDataUrlFromFile = getDataUrlFromFile\r\nimageCompression.getFilefromDataUrl = getFilefromDataUrl\r\nimageCompression.loadImage = loadImage\r\nimageCompression.drawImageInCanvas = drawImageInCanvas\r\nimageCompression.drawFileInCanvas = drawFileInCanvas\r\nimageCompression.canvasToFile = canvasToFile\r\nimageCompression.getExifOrientation = getExifOrientation\r\n\r\nimageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight\r\nimageCompression.followExifOrientation = followExifOrientation\r\nimageCompression.cleanupMemory = cleanupCanvasMemory\r\nimageCompression.version = '1.0.11'\r\n\r\nexport default imageCompression\r\n","import React, { useState } from \"react\";\n// import { JPGCompressor, downloadJPG } from \"./Algorithms/JPGCompressor\";\n// import { PNGCompressor, downloadPNG } from \"./Algorithms/PNGCompressor\";\nimport {\n  downloadWEBP,\n  WEBPCompressor,\n} from \"./Algorithms/compression/WEBPCompressor\";\nimport {\n  PDFCompressor,\n  downloadPDF,\n} from \"./Algorithms/compression/PDFCompressor\";\nimport { PNG_JPG_Compressor } from \"./Algorithms/compression/PNG_JPG_Compressor\";\nconst Compression = () => {\n  const [file, setFile] = useState(null);\n  const [ratio, setRatio] = useState(50);\n  const [success, setSuccess] = useState(false);\n  const [load, setLoading] = useState(false);\n  const [type, setType] = useState({\n    from: \"\",\n  });\n  const showName = (e) => {\n    setFile(e.target.files[0]);\n  };\n  const fileType = (e) => {\n    //console.log(e.target.value);\n    setType({\n      ...type,\n      [e.target.name]: e.target.value,\n    });\n  };\n  const submit = (e) => {\n    e.preventDefault();\n    if (file === null) {\n      alert(\"Please first select file and types\");\n      return;\n    }\n    if (file.size > 112582912) {\n      alert(\"File Size must be less then 11mb.\");\n      return;\n    }\n    if (type.from === \"\" || type.from === \"Original File Types\") {\n      alert(\"'From' file type is not selected!\");\n      return;\n    }\n    if (type.from.toLowerCase() !== file.name.split(\".\").pop()) {\n      if (type.from === \"JPEG/JPG\") {\n        if (\n          file.name.split(\".\").pop() !== \"jpg\" &&\n          file.name.split(\".\").pop() !== \"jpeg\"\n        ) {\n          alert(\n            \"Mismatch in selected file type: \" +\n              file.name.split(\".\").pop() +\n              \" with 'From' Select box: \" +\n              type.from.toLowerCase()\n          );\n          return false;\n        }\n      } else {\n        alert(\n          \"Mismatch in selected file type: \" +\n            file.name.split(\".\").pop() +\n            \" with 'From' Select box: \" +\n            type.from.toLowerCase()\n        );\n        return false;\n      }\n    }\n    setSuccess(false);\n    setLoading(true);\n    // if (type.from === \"JPG\" || type.from === \"JPEG\") {\n    //   let reader = new FileReader();\n    //   reader.readAsDataURL(file);\n    //   reader.onload = function() {\n    //     const dataURL = reader.result;\n    //     JPGCompressor(dataURL);\n    //   };\n    // }\n    if (\n      type.from === \"JPEG/JPG\" ||\n      type.from === \"PNG\" ||\n      type.from === \"ICO\"\n    ) {\n      PNG_JPG_Compressor(file, setLoading, setSuccess, ratio);\n    }\n    if (type.from === \"WEBP\") {\n      let reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = function () {\n        const dataURL = reader.result;\n        WEBPCompressor(dataURL, setLoading, setSuccess);\n      };\n    }\n    if (type.from === \"PDF\") {\n      let reader = new FileReader();\n      reader.readAsArrayBuffer(file);\n      reader.onload = function () {\n        const dataURL = reader.result;\n        PDFCompressor(dataURL);\n        setSuccess(true);\n        setLoading(false);\n      };\n    }\n  };\n  //handle download accordingly\n  const download = () => {\n    if (type.from === \"WEBP\") {\n      downloadWEBP(file.name.split(\".\")[0], setSuccess, ratio); //passing file name\n    }\n    if (type.from === \"PDF\") {\n      downloadPDF(file.name.split(\".\")[0], setSuccess); //passing file name\n    }\n  };\n  const handelRatio = (e) => {\n    setRatio(Number(e.target.value));\n  };\n  return (\n    <section className=\"container\">\n      <div className=\"level is-mobile\">\n        <div className=\"level-item has-text-centered\">\n          <div className=\"field\">\n            <div className=\"control has-icons-left\">\n              <div className=\"select is-rounded\">\n                <select name=\"from\" onChange={fileType}>\n                  <option defaultValue>Original File Types</option>\n                  {/* <option>PDF</option> */}\n                  <option>PNG</option>\n                  <option>JPEG/JPG</option>\n                  <option>WEBP</option>\n                  <option>ICO</option>\n                </select>\n              </div>\n              <div className=\"icon is-small is-left\">\n                <i className=\"fas fa-globe\"></i>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div className=\"level is-mobile\">\n        <div className=\"level-item has-text-centered\">\n          <div className=\"file is-dark has-name is-boxed\">\n            <label className=\"file-label\">\n              <input\n                className=\"file-input\"\n                type=\"file\"\n                name=\"image\"\n                accept=\"image/*\"\n                onChange={showName}\n              />\n              <span className=\"file-cta\">\n                <span className=\"file-icon\">\n                  <i className=\"fas fa-upload\"></i>\n                </span>\n                <span className=\"file-label\">Choose a file…</span>\n              </span>\n              <span className=\"file-name\">\n                {file === null ? null : file.name}\n              </span>\n            </label>\n          </div>\n        </div>\n      </div>\n      <div className=\"level is-mobile\">\n        <div className=\"level-item has-centered\">\n          <h6>Compression Ratio: {ratio}%</h6>\n        </div>\n      </div>\n      <div className=\"level is-mobile\">\n        <div className=\"level-item has-centered\">\n          <input\n            className=\"slider\"\n            step=\"1\"\n            id=\"ratio\"\n            min=\"0\"\n            max=\"99\"\n            onChange={handelRatio}\n            value={ratio}\n            type=\"range\"\n          />\n        </div>\n      </div>\n      <div className=\"level has-centered\">\n        {load ? (\n          <div className=\"columns level-item has-centered\">\n            <div className=\"column is-two-thirds\">\n              <progress className=\"progress is-dark\" max=\"100\">\n                30%\n              </progress>\n            </div>\n          </div>\n        ) : (\n          <div className=\"level-item has-centered\">\n            <button className=\"button is-dark is-rounded\" onClick={submit}>\n              <span className=\"icon\">\n                <i className=\"fas fa-dice-d20\"></i>\n              </span>\n              <span>Convert</span>\n            </button>\n          </div>\n        )}\n      </div>\n      <canvas\n        className=\"container has-centered\"\n        id=\"jpgtopng\"\n        style={{ display: \"none\" }}\n      ></canvas>\n      <div className=\"has-centered\">\n        {success ? (\n          <div className=\"has-centered\">\n            <div className=\"container level-item has-centered\">\n              <p>Your converted file is ready to download!</p>\n            </div>\n            <div className=\"container level-item has-centered\">\n              <p id=\"size\"></p>\n            </div>\n            <br />\n            <div className=\"container level-item has-centered\">\n              <a\n                onClick={download}\n                id=\"downloader\"\n                href=\"#i\"\n                className=\"button is-dark is-outlined\"\n              >\n                <span className=\"icon is-small\">\n                  <i className=\"fas fa-download\"></i>\n                </span>\n              </a>\n            </div>\n          </div>\n        ) : null}\n      </div>\n      <hr />\n    </section>\n  );\n};\n\nexport default Compression;\n","import imageCompression from \"browser-image-compression\";\nexport const PNG_JPG_Compressor = (file, setLoading, setSuccess, ratio) => {\n  let si = (100 - ratio) / 100;\n  var options = {\n    maxSizeMB: si,\n    maxWidthOrHeight: 1920,\n    useWebWorker: true,\n  };\n  //console.log(si);\n  imageCompression(file, options)\n    .then(function (compressedFile) {\n      let blob = compressedFile;\n      let reader = new FileReader();\n      reader.readAsDataURL(blob);\n      reader.onloadend = () => {\n        let dataURI = reader.result;\n        setLoading(false);\n        setSuccess(true);\n        document.getElementById(\"size\").innerText =\n          \"File Size: \" + (compressedFile.size / 1024).toFixed(2) + \"kb\";\n        document.getElementById(\"downloader\").download = file.name;\n        document.getElementById(\"downloader\").href = dataURI;\n      };\n    })\n    .catch(function (error) {\n      console.log(error.message);\n    });\n};\n","/**\n * Algorithm for JPG Compressor\n */\nexport const WEBPCompressor = (dataURL, setLoading, setSucess) => {\n  var canvas = document.getElementById(\"jpgtopng\");\n  var ctx = canvas.getContext(\"2d\");\n  var image = new Image();\n  ctx.canvas.width = window.innerWidth;\n  ctx.canvas.height = window.innerHeight;\n  image.onload = function () {\n    ctx.drawImage(image, 0, 0, window.innerWidth, window.innerHeight);\n  };\n  image.src = dataURL;\n  setSucess(true);\n  setLoading(false);\n  let dataURI = document\n    .getElementById(\"jpgtopng\")\n    .toDataURL(\"image/webp\", 1.0)\n    .replace(/^data:image\\/[^;]/, \"data:application/octet-stream\");\n  var head = \"data:image/webp;base64,\";\n  var imgFileSize = Math.round(((dataURI.length - head.length) * 3) / 4) / 1024;\n  document.getElementById(\"size\").innerText =\n    \"File Size: \" + imgFileSize.toFixed(2) + \"kb \\nFile size may vary\";\n};\nexport const downloadWEBP = (name, setSucess, ratio) => {\n  //file name as argument\n  document.getElementById(\"downloader\").download = name + \".webp\";\n  // converting data uri to blob aken form github gist\n  let si = (100 - ratio) / 100;\n  if (si === 1) {\n    si = 1.0;\n  }\n\n  let dataURI = document\n    .getElementById(\"jpgtopng\")\n    .toDataURL(\"image/webp\", si)\n    .replace(/^data:image\\/[^;]/, \"data:application/octet-stream\");\n  let byteString = atob(dataURI.split(\",\")[1]);\n\n  // separate out the mime component\n  let mimeString = dataURI.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n\n  // write the bytes of the string to an ArrayBuffer\n  let arrayBuffer = new ArrayBuffer(byteString.length);\n  let _ia = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < byteString.length; i++) {\n    _ia[i] = byteString.charCodeAt(i);\n  }\n\n  let dataView = new DataView(arrayBuffer);\n  let blob = new Blob([dataView], { type: mimeString });\n\n  document.getElementById(\"downloader\").href = URL.createObjectURL(blob);\n  setSucess(false);\n};\n","/**\n * Algorithm for PDF Compressor\n */\n\nexport const PDFCompressor = dataURL => {\n  console.log(dataURL);\n  var canvas = document.getElementById(\"jpgtopng\");\n  var ctx = canvas.getContext(\"2d\");\n  var image = new Image();\n  ctx.canvas.width = window.innerWidth;\n  ctx.canvas.height = window.innerHeight;\n  image.onload = function() {\n    ctx.drawImage(image, 0, 0, window.innerWidth, window.innerHeight);\n  };\n  image.src = dataURL;\n};\nexport const downloadPDF = name => {\n  //file name as argument\n  document.getElementById(\"downloader\").download = name + \".pdf\";\n  // converting data uri to blob aken form github gist\n  //   let dataURI = document\n  //     .getElementById(\"jpgtopng\")\n  //     .toDataURL(\"image/jpeg\", 0.3);\n};\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}"],"sourceRoot":""}